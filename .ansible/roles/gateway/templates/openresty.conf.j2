user www-data;
worker_processes auto;
error_log /var/log/openresty/error.log warn;
pid /var/run/openresty.pid;

events {
    worker_connections 1024;
}

http {
    include       /etc/openresty/mime.types;
    default_type  application/octet-stream;

    # Define a JSON log format for easy parsing by Promtail/Loki
    log_format json_combined escape=json
      '{'
        '"time_local":"$time_local",'
        '"remote_addr":"$remote_addr",'
        '"remote_user":"$remote_user",'
        '"request":"$request",'
        '"status": "$status",'
        '"body_bytes_sent":"$body_bytes_sent",'
        '"request_time":"$request_time",'
        '"http_referrer":"$http_referer",'
        '"http_user_agent":"$http_user_agent",'
        '"http_x_forwarded_for":"$http_x_forwarded_for"'
      '}';

    access_log /var/log/openresty/access.log json_combined;

    sendfile        on;
    tcp_nopush      on;
    keepalive_timeout 65;
    gzip on;

    # === CrowdSec, GeoIP & WAF Integration ===
    lua_shared_dict crowdsec_cache 10m;
    lua_package_path "/usr/local/share/lua-resty-waf/lib/?.lua;/usr/local/share/lua/5.1/?.lua;;";

    init_by_lua_block {
        -- Load CrowdSec bouncer
        require "resty.crowdsec"

        -- Load WAF
        waf = require("resty.waf")

        -- === GeoIP FFI Initialization ===
        local ffi = require("ffi")
        ffi.cdef[[
            typedef struct MMDB_s {
                int ip_version;
                int node_count;
                int record_size;
                int node_byte_size;
                int search_tree_size;
                int data_section_size;
                int metadata_section_size;
                const uint8_t *file_content;
            } MMDB_s;
            typedef struct MMDB_lookup_result_s {
                int found_entry;
                struct MMDB_entry_s {
                    const MMDB_s *mmdb;
                    uint32_t offset;
                } entry;
            } MMDB_lookup_result_s;
            typedef struct MMDB_entry_data_s {
                int has_data;
                uint16_t type;
                const uint8_t *bytes;
                uint32_t data_size;
            } MMDB_entry_data_s;

            int MMDB_open(const char *const filename, uint32_t flags, MMDB_s *const mmdb);
            int MMDB_close(MMDB_s *const mmdb);
            int MMDB_lookup_string(MMDB_s *const mmdb, const char *const ipstr, int *const gai_error, int *const mmdb_error);
            int MMDB_get_value(MMDB_entry_s *const entry, MMDB_entry_data_s *const entry_data, ...);
        ]]

        -- Open the GeoIP database
        mmdb = ffi.new("MMDB_s[1]")
        local status = ffi.C.MMDB_open("/usr/share/geoip/GeoLite2-Country.mmdb", 0, mmdb)
        if status ~= 0 then
            ngx.log(ngx.ERR, "Can't open GeoIP database: /usr/share/geoip/GeoLite2-Country.mmdb")
            mmdb = nil
        end

        -- Create a set of blocked countries for fast lookups
        local blocked_countries = {
        {% for country in gateway_geoip_country_blocklist %}
            "{{ country }}",
        {% endfor %}
        }
        blocked_countries_set = {}
        for _, v in ipairs(blocked_countries) do
            blocked_countries_set[v] = true
        end
    }

    access_by_lua_block {
        -- 1. Run CrowdSec bouncer
        local crowdsec = require("resty.crowdsec")
        local res, err = crowdsec:handle()
        if not res then
            ngx.log(ngx.ERR, "CrowdSec bouncer error: ", err)
            return
        end
        if res.action ~= "allow" then
            ngx.exit(res.status)
        end

        -- 2. Run GeoIP check via FFI
        if mmdb then
            local ip = ngx.var.remote_addr
            local gai_error = ffi.new("int[1]")
            local mmdb_error = ffi.new("int[1]")
            local result = ffi.C.MMDB_lookup_string(mmdb[0], ip, gai_error, mmdb_error)

            if result.found_entry == 1 then
                local entry_data = ffi.new("MMDB_entry_data_s[1]")
                local status = ffi.C.MMDB_get_value(result.entry, entry_data, ffi.cast("const char *", "country"), ffi.cast("const char *", "iso_code"), nil)
                if status == 0 and entry_data.has_data == 1 then
                    local country_code = ffi.string(entry_data.bytes, entry_data.data_size)
                    if blocked_countries_set[country_code] then
                        ngx.exit(403)
                    end
                end
            end
        end

        -- 3. If not blocked, run WAF
        local results, err = waf:exec()
        if err then
            ngx.log(ngx.ERR, "WAF error: ", err)
        end
        if results and results.action == "BLOCK" then
            ngx.exit(403)
        end
    }

    # Include server blocks from other services
    include /etc/openresty/conf.d/*.conf;

    # Default server block to catch unhandled requests
    server {
        listen 80;
        server_name jgirod.com.ar;

        root /var/www/jgirod.com.ar/html;
        index index.html index.htm;

        location / {
            try_files $uri $uri/ /index.html;
        }
    }

    # Default server block to catch unhandled requests
    server {
        listen 80 default_server;
        server_name _;
        return 444; # Connection closed without response
    }
}